---
title: "Progetto di SAD"
output:
  pdf_document: default
  html_notebook: default
---

---
 fontsize: 12pt
---

# Introduzione
Mai come al giorno d'oggi il tema immigrazione risulta essere attuale, trattato spesso dai media e discusso dai politici. 
L'immigrazione è anche il tema alla base di questo progetto il quale scopo è quello di analizzare i dati forniti da un'indagine effettuata dall'ISTAT. Il titolo della tavola utilizzata è *Cittadini non comunitari regolarmente presenti per motivo della presenza* e, come si evince da questo, il progetto si focalizza sul motivo della presenza di questi cittadini. 

Per definizione, i cittadini comunitari sono tutti coloro che risultano essere in possesso della cittadinanza di uno degli stati membri della Comunità Europea. È bene ricordare che gli stati facenti parte dell'Unione Europea ad oggi sono: Austria, Belgio, Bulgaria, Cipro, Croazia, Danimarca, Estonia, Finlandia, Francia, Germania, Grecia, Irlanda, Italia, Lettona, Lituania, Lussemburgo, Malta, Paesi Bassi, Polonia, Portogallo, Regno Unito, Repubblica Ceca, Romania, Slovacchia, Slovenia, Spagna, Svezia, Ungheria.
Lo studio è stato effettuato su cittadini non comunitari, quindi aventi cittadinanza di altri paesi.

I dati risultano essere aggiornati al 1 gennaio 2018. 
La tabella utilizzata è composta da 20 righe rappresentanti le regioni italiane e 5 colonne rappresentanti le maggiori motivazioni, in particolare: lavoro, famiglia, studio, asilo e altro. I dati sono sottoforma di percentuale.
Utilizzando metodi statistici, il progetto verterà sul raggiungere diversi obiettivi:

* Individuare i legami fra le diverse modalità assunte.
* Individuare valori *outlaw*, ovvero anomali perchè fuori dal range
* Definire cluster per raggruppare regioni ritenute simili

Il linguaggio di programmazione utilizzato all'interno del progetto per eseguire l'analisi dei dati è R.

La prima cosa da fare è costruire la tabella all'interno del workspace di R. Iniziamo quindi a definire per ogni modalità un vettore e inserire i rispettivi valori della colonna.

```{r}
lavoro <- c(28.3, 26.1, 30.9, 38.8, 22.1, 35.2, 23.5, 31.4, 39.3, 30.5,
            31.4, 34.1, 28.0, 10.9, 41.6, 21.6, 21.6, 23.6, 28.0, 28.2)
famiglia <- c(46.6, 53.2, 44.8, 47.3, 50.9, 48.6, 44.5, 50.7, 39.8, 48.6, 
              45.0, 37.1, 45.7, 18.6, 29.1, 29.3, 25.9, 29.2, 32.8, 34.4)
studio <- c(4.8, 1.9, 2.8, 3.1, 2.6, 1.5, 2.8, 3.2, 3.2, 5.1, 3.1, 4.7, 
            2.3, 0.7, 1.0, 1.6, 1.1, 1.8, 0.7, 2.1)
asilo <- c(18.1, 16.6, 17.7, 9.4, 22.4, 13.2, 26.6, 12.7, 14.5, 12.5, 18.1,
           14.3, 20.3, 67.1, 23.5, 43.0, 46.0, 42.8, 32.6, 31.0)
altro <- c(2.16, 2.20, 3.86, 1.57, 1.90, 1.54, 2.58, 2.04, 3.23, 3.29, 2.46,
           9.79, 3.70, 2.75, 4.83, 4.40, 5.46, 2.55, 5.87, 4.33)
```

Utilizzando il comando *cbind* è possibile creare una matrice a partire da vettori della stessa lunghezza. Inoltre i dati verranno inseriti per colonne (per questo la c davanti bind). Per inserire i dati per riga, il comando da utilizzare è *rbind*

```{r}
tabella <- cbind(lavoro, famiglia, studio, asilo, altro)
```

A questo punto utilizziamo la funzione *rownames* a cui diamo in input la matrice creata in precedenza. Questa funzione ci permette di assegnare ad ogni riga un nome, che in questo caso è quello delle regioni italiane. Fatto questo stampiamo la matrice appena creata semplicemente scrivendone il nome.


```{r}
rownames(tabella) <- c("Piemonte", "Valle d'Aos", "Liguria",
                       "Lombardia", "T-A Adige","Veneto", 
                       "F-V Giulia", "Em-Romag", "Toscana", 
                       "Umbria", "Marche", "Lazio", "Abruzzo", 
                       "Molise", "Campania", "Puglia", 
                       "Basilicata", "Calabria", "Sicilia", "Sardegna")
tabella
```
\newpage

# Distribuzioni di frequenza semplice

Nella statistica descrittiva è possibile avere tre tipologie di variabili:

1. **Variabili qualitative**, ovvero variabili il cui valore non è numerico. Ad esempio, il colore dei capelli

2. **Variabili quantitative**, variabile il cui valore è di tipo numerico. Ad esempio, l'altezza.

3. **Variabili ordinabili**, in grado di essere ordinate. I valori possono essere di tipo numerico o testuale.

I dati a nostra dispozione all'interno della tabella sono di tipo numero e ricadono quindi nella seconda tipologia descritta.
Utilizziamo le *distribuzioni di frequenza* per analizzare la distribuzione dei dati, andando a sintetizzare ciò che essi rappresentano.

Siccome molto spesso è preferibile raggruppare le informazioni in classi quando si hanno variabili quantitative a disposizione, sono state definite 5 classi:

```{r}
classi <- c(0, 15, 20, 30, 50, 70)
```

Definite le classi andiamo ad utlizzare un altro comando, *cut()*, a cui diamo in input il vettore dei dati da classificare e il vettore delle classi andando così a inserire ogni valore nell'intervallo corrispondente.

## Frequenza assoluta

Per costruire una distribuzione di frequenza in R utilizziamo la funzione *table()* che ci aiuta a calcola le frequenze assolute dei dati a disposizione.

```{r}
table(cut(lavoro, classi))
```

Da questa suddivisione, possiamo notare due aspetti interessanti: 

* In ben nove regioni almeno 1/3 dei cittadini non comunitari si trova lì per motivi di lavoro.

* Solo in una regione, per la precisione nel Molise, il tasso dei cittadini non comunitari che giustifica la propria presenza per questioni di lavoro è estremamente basso rispetto alle altre regioni ed è del 10.9%.

Applichiamo la stessa funzione anche agli altri vettori rappresentanti le restanti modalità ed effettuiamo un'analisi.


```{r}
table(cut(famiglia, classi))
```

Guardando questi dati notiamo che:

* almeno il 50% dei cittadini non comunitari residenti in tre regioni giustifica la propria presenza per questioni legate alla famiglia. Queste regioni sono Valle d'Aosta, Trentino-Alto Adige e Emilia-Romagna.

* solo in una regione il tasso è inferiore del 20%. Riferendoci alla tabella, scopriamo che è sempre il Molise con un tasso del 18.6%.


```{r}
table(cut(studio, classi))
```

Notiamo:

* lo studio è motivo di presenza di una percentuale molto bassa di cittadini non comunitari. Di fatti, guardando alla tabella, è possibile notare che le percentuali sono quasi tutte inferiori al 5%.


```{r}
table(cut(asilo, classi))
```

Notiamo:

* una sola regione il tasso dei cittadini non comunitari che si trovano lì per asilo è superiore al 50%. Questa regione è il Molise con una percentuale del 67.1%

* in ben sei regioni, la presenza di cittadini non comunitari per asilo è inferiore al 15%, in particolare in Lombardia, Veneto, Emilia-Romagna, Toscana, Umbria e Lazio.

```{r}
table(cut(altro, classi))
```

Notiamo:

* la percentuale di cittadini non comunitari la cui presenza è dovuta a motivi non ben specificati è in tutte le regioni al di sotto del 15%. In particolare, guardando la tabella i valori non superano neanche il 10%.

## Frequenze relative

Per calcolare la distribuzione delle **frequenze relative** basta dividere l'output della funzione *table()* per la lunghezza del vettore considerato, ottenuta con la funzione *length()*

```{r}
table(cut(lavoro, classi))/length(lavoro)
```

Notiamo:

* solo il 5% delle regioni italiane ospita cittadini non comunitari la cui presenza è dovuta al lavoro per un tasso inferiore al 15%
* il restante 95% delle regioni è abitato da cittadini non comunitari presenti a causa del lavoro per un tasso superiore al 20%

Com'è possibile vedere, i risultati forniti dall'analisi delle frequenze relative corrispondono a quelli delle frequenze assolute.
Completiamo calcolando le frequenze relative per le altre modalità.

```{r}
table(cut(famiglia, classi))/length(famiglia)
```

```{r}
table(cut(studio, classi))/length(studio)
```

```{r}
table(cut(asilo, classi))/length(asilo)
```

```{r}
table(cut(altro, classi))/length(altro)
```

## Frequenze assolute cumulate

In R è possibile cumulare le varie frequenze sfruttando la funzione *cumsum()*.
Vediamo di seguito i valori calcolati

```{r}
cumsum(table(cut(lavoro, classi)))
```

```{r}
cumsum(table(cut(famiglia, classi)))
```

```{r}
cumsum(table(cut(studio, classi)))
```

```{r}
cumsum(table(cut(asilo, classi)))
```

```{r}
cumsum(table(cut(altro, classi)))
```

## Frequenze relative cumulate

```{r}
cumsum(table(cut(lavoro, classi))/length(lavoro))

```

```{r}
cumsum(table(cut(famiglia, classi))/length(famiglia))

```

```{r}
cumsum(table(cut(studio, classi))/length(studio))

```

```{r}
cumsum(table(cut(asilo, classi))/length(asilo))

```

```{r}
cumsum(table(cut(altro, classi))/length(altro))

```

\newpage

# Le rappresentazioni grafiche

Le rappresentazioni grafiche ci permettono di confrontare e analizzare i dati contenuti nella tabella iniziale in maniera decisamente più veloce.
Esistono moltissime tipologie di grafici ma non sempre sono tutti adatti a raggiungere lo scopo o a visualizzare in maniera adatta i dati che si vogliono rappresentare.
La creazione di grafici e la rappresentazione di dati sono attività che ricadono nella data visualization.

Per i dati a nostra disposizione, si è scelto di utilizzare un grafico a barre in modo da rendere chiara la differenza e facilitare i confronto fra le varie regioni.
In R è possibile creare un grafico a barre attraverso il comando *barplot()*.
All'interno del comando *barplot* sono state specificate alcune opzioni, ovvero:

* *col* ci colorare le barre del grafico

* *ylim* per indicare il punto dove far iniziare e far finire l'asse delle ordinate

* *las* per stampare le label dell'asse delle ascisse in verticale

\newpage

In questo primo *barplot* sull'asse delle ascisse sono state inserite le venti regioni italiane, mentre sull'asse delle ordinate i valori della tabella corrispondenti alla colonna "lavoro".

```{r}
barplot(tabella[,1], col=1:20, ylim = c(0, 50), las=2, 
        main = "Cittadini non comunitari residenti per motivi di lavoro")
```

Come visto in precedenza con l'analisi delle frequenze relative, anche qui notiamo che:

* il Molise è la regione con il tasso più basso di cittadini non comunitari la cui presenza è dovuta a ragioni di lavoro.

* la Campania, la Toscana e la Lombardia sono le tre regioni con il tasso più alto.

\newpage

Passiamo adesso all'analisi della modalità "famiglia"

```{r}
barplot(tabella[,2], col=1:20, ylim = c(0,60), las=2, 
        main = "Cittadini non comunitari residenti per motivi di famiglia")
```

Possiamo anche qui vedere che, per quanto riguarda i motivi di famiglia:

* il Molise ha il tasso più basso fra tutte le regioni

* il tasso è più alto del 50% in Valle d'Aosta, Emilia-Romagna e Trentino-Alto Adige

\newpage
Per quanto riguarda lo studio invece:

```{r}
barplot(tabella[,3], col=1:20, ylim = c(0,6), las=2, 
        main = "Cittadini non comunitari residenti per motivi di studio")
```

Quello che si nota è che in generale i cittadini non comunitari non vengono in Italia per studiare in quanto i tassi
risultano estremamente bassi in tutte le regioni con i più bassi in Molise e Sicilia.

\newpage

La situazione di asilo politico è la seguente:

```{r}
barplot(tabella[,4], col=1:20, ylim = c(0,70), las=2, 
        main = "Cittadini non comunitari residenti per asilo")
```


Fra le osservazioni interessanti di questa situzione abbiamo:

* il Molise risulta avere il tasso più alto di cittadini non comunitari rifugiati.

* la Lombardia, insieme a qualche altra regione del nord Italia, presenta il tasso più basso

\newpage

Per quanto riguarda le motivazioni non specificate:

```{r}
barplot(tabella[,5], col=1:20, ylim = c(0,10), las=2, 
        main = "Cittadini non comunitari residenti per altri motivi")
```
È possibile notare che i dati raccolti per motivi non ben specificati sono decisamente bassi.
Si differenzia solo la situazione del Lazio, che presente un tasso decisamente elevato rispetto alle altre.

\newpage

La tabella fornita dall'ISTAT comprende anche una riga riguardante tutta l'Italia. Procediamo quindi alla creazione di un grafico a barre dove sull'asse
orizzontale disponiamo le modalità che possono essere assunte dal campione e sull'asse verticale il valore della corrispondente modalità
Visto che utilizzeremo questi dati solo per la creazione di alcuni grafici, non aggiungiamo la riga alla matrice precedente ma ne creiamo una nuova. 

```{r}
italia <- rbind(c(33.6, 42.6, 3.0, 17.1, 3.63))
colnames(italia) <- c("Lavoro", "Famiglia", "Studio", "Asilo", "Altro") 
barplot(italia[1,], col = 1:5)
```

Come detto prima, R fornisce anche la possibilità di utilizzare altre tipi di diagrammi, come quelli a torta, che suddividono un cerchio in diversi settori tanti quante sono le modalità che può assumere il campione.
Per creare un diagramma a torta in R è possibile utilizzare la funzione *pie()* 
```{r}
pie(italia[1,], col=1:5)
```

È possibile applicare diversi tipi di tratteggio al diagramma a torta, utilizzando linee al posto della tinta unita. Aggiungengo le opzione
*density* e *angle* è possibile impostare la densità delle linee del tratteggio e l'angolo che esse devono assumere.

```{r}
pie(italia[1,], density = 18, angle= 15+10*(1:5), col = 1:5)
```

Queste sono solo due delle diverse tipologie di grafico messe a disposizione da R. È possibile notare che la percezione della distribuzione dataci dal grafico a barre è la stessa di quella del grafico a torta, cambia solo la modalità di visualizzazione dei dati. 

**Diagramma di Pareto**

Il diagramma di Pareto è un grafico che rappresenta l'importanza delle differenze causate da un certo fenomeno. Contiene al suo interno un diagramma a barre verticali con le modalità organizzate in maniera decrescente rispetto alla loro frequenza relativa. Le frequenze relative sono rappresentate sottoforma cumulata come una curva. Il suo scopo è quello di aiutare a capire quali sono i maggiori fattori che hanno influenza su un dato fenomeno.

Prendiamo come modalità in analisi l'asilo politico. Con l'opzione *drop=FALSE* diciamo ad R di includere anche le label della righe.

```{r}
tabella[,4,drop=FALSE]
```

La prima cosa che facciamo è ordinare in maniera decrescente in base alla modalità *asilo* che è quella che vogliamo analizzare.

```{r}
ordinata <- tabella[order(asilo, decreasing=TRUE),4 , drop = FALSE]
ordinata
```

```{r}
asilo_freqRel <- ordinata[,1]/sum(asilo)
asilo_freqRelCum <- cumsum(asilo_freqRel)
asilo_freqRelCum
```

```{r}
pareto <- barplot(asilo_freqRel, ylim = c(0,1.1), col=1:20, las=2)
lines(pareto, asilo_freqRelCum, type = "b", pch=16)
text(pareto-0.01, asilo_freqRelCum+0.03, paste(format(asilo_freqRelCum *100, digits=2), "%"))
```

Quello che possiamo notare dal diagramma di Pareto è che circa il 70% dei cittadini non comunitari presenti in Italia per motivi di asilo politico risiede nelle prime dieci regioni sopra elencate. Notasi anche che in queste dieci regioni figura tutto il Sud Italia, composto da ben 8 regioni.

Consideriamo sempre il vettore quantitativo *lavoro*. Attraverso l'utilizzo della funzione *plot()* è possibile visualizzare su un piano cartesiano il valore assunto da ogni regione italiana. Nella seguente riga di codice sono state utilizzate due opzioni, *xlab* e *ylab*, che ci permettono di impostare manualmente il valore dell'etichetta degli assi.

```{r}
plot(lavoro, col="blue", ylim = c(8,50), xlab = "Regioni", ylab="Tasso per lavoro")
```

È possibile connettere i punti del grafico con delle linee utilizzando l'apposito comando *lines()* 

```{r}
plot(lavoro, col="blue", ylim = c(8,50), xlab = "Regioni", ylab="Tasso per lavoro")
lines(lavoro, col="red")
```

La creazione di plot non ci permette di dedurre nuove informazioni rispetto a quello che sappiamo già.

Possiamo anche creare un unico grafico che ci permetta di confrontare i valori assunti dalle diverse modalità. 
Associamo ad ogni modalità un simbolo diverso:

* $*$ per indicare i valori di lavoro
* $+$ per indicare i valori di famiglia
* $x$ per indicare i valori di studio
* $o$ per indicare i valori di asilo
* $-$ per indicare i valori di altro

Useremo la funzione *points()* per aggiungere altri punti al grafico già esistente. Fra i parametri utilizzati compare *pch* che ci permette di indicare quale simbolo utilizzare per rappresentare i valori. La funzione *legend()* serve a creare una legenda all'interno del grafico disegnato. Il parametro *ncol* utilizzato all'interno della funzione *legend()*
ci permette di indicare il numero di colonne da utilizzare.

```{r}
plot(lavoro, pch="*", ylim = c(0, 90), col="blue", ylab="Tasso", xlab="Indici regioni")
points(famiglia, pch="+", col="red")
points(studio, pch="x", col="green")
points(asilo, pch="o", col="magenta")
points(altro, pch="-", col="black")

legend(1, 90, c("lavoro", "famiglia", "studio", "asilo", "altro"), pch=c("*","+", "x", "o", "-"),
        col = c("blue", "red", "green", "magenta", "black"), ncol = 3)

```


### Istogrammi

Gli istogrammi sono una particolare rappresentazione grafica di una distribuzione di frequenza in classi e vengono utilizzati per le variabili *quantitative*
Questa tipologia di rappresentazione grafica viene ottenuta mediante rettangoli adiacenti aventi per basi segmenti i cui estremi corrispondono agli estremi delle classi. Fissate le basi, le altezze devono essere tali che l'area di ogni rettangolo risultante sia uguale alla frequenza relativa o assoluta della classe stessa.
È possibile creare un'istogramma in R utilizzando la funzione *hist()*. 
Questo comando prevede diverse opzioni interessanti: 

* *freq*, che può valere FALSE indicando così di utilizzare la frequenza relativa, oppure può essere impostato a TRUE per utilizzare la frequenza assoluta. Di default è impostato a TRUE se e solo se le classi sono equidistanti.

```{r}
h <- hist(famiglia, freq = TRUE, col = 1:5, main="Istogramma per motivi di famiglia", ylab="Frequenza assoluta classi", xlab = "Classi")
```

Utilizzando il comando *str()* R è in grado di fornirci informazioni aggiuntive sulla creazione dell'istogramma, come la suddivisione in classi utilizzata.

```{r}
str(h)
```

Com'è possibile vedere, le informazioni fornite da R riguardo l'istogramma sono diverse:

* *breaks* è un vettore contenente la suddivisione in classi utilizzata
* *counts* è un vettore i quali valori indicano il numero di elementi che ricade in ogni classe
* *density* è il vettore con le densità delle classi stimate
* *mids* vettore contenente i punti centrali delle classi
* *xname* è il nome del vettore di dati su cui si basa l'istogramma
* *equidist* un valore booleano per indicare se la distanza fra i valori di breaks è uguale

Da queste informazioni è possibile ricavare la frequenza relativa moltiplicando il vettore *density* per l'ampiezza delle classi.
In questo caso, l'ampiezza delle classi è 5.

```{r}
fr <- h$density * 5
fr
```

Utilizziamo adesso il vettore delle classi definito precedentemente durante il calcolo delle frequenze per definire un nuovo istogramma.

```{r}
h <- hist(famiglia, freq = TRUE, col = 1:5, main="Istogramma per motivi di famiglia", ylab="Frequenza assoluta classi", xlab = "Classi", breaks = classi)
```

### Boxplot

Consideriamo il campione dei valori assunti da una variabile quantitativa "Lavoro". Ordinando il vettore in ordine crescente, è possibile calcolare dei particolari valori chiamati *quartili*. Prende il nome di **primo quartile** e  si indica con $Q_{1}$, il valore per il quale il 25% dei dati si trova alla sua sinistra e il restante 75% alla sua destra. In maniera speculare, il **terzo quartile**, indicato con $Q_{3}$ è il valore per il quale il 25% dei dati sono alla sua destra e il 75% alla sua sinistra. Il **secondo quartile** indicato con $Q_{2}$ è il valore che alla sua destra il 50% dei dati e alla sua sinistra il restante 50% ed è chiamato anche **mediana**. I valori $Q_{0}$ e $Q_{1}$ rappresentano rispettivamente il valore *minimo* e il valore *massimo* del campione. 
R fornisce le funzioni *quantile()* e *summary()* che ci permettono i valori del minimo ($Q_{0}$) e del massimo ($Q_{4}$), della mediana ($Q_{2}$), del primo e del terzo quartile ($Q_{1}$ e $Q_{3}$).
Riferendoci al vettore *lavoro*:

```{r}
quantile(lavoro)
```

```{r}
summary(lavoro)
```

Calcolati i quartili è possibile definire cos'è un boxplot. Un **boxplot**, detto anche diagramma a scatala con baffi, è un grafico relativo a caratteri quantitativi ottenuto a partire dai quartili. Il suo scopo è quello di descrivere le caratteristiche salienti della distribuzione. Il disegno della scatola ha come estremi $Q_{1}$ e $Q_{3}$ ed ha una linea orizzontale in corrispondenza di $Q_{2}$. Sia in alto che in basso sono presenti due linee orizzontali dette *baffi*. Il baffo inferiore corrisponde al valore più piccolo fra le osservazioni ed è maggiore o uguale del valore $Q_{1}$ - 1.5 $*$ ($Q_{3}$ - $Q_{1}$), mentre il baffo superiore corrisponde al valore più alto delle osservazioni ed è minore o uguale del valore $Q_{3}$ + 1.5 $*$ ($Q_{3}$ - $Q_{1}$). La distanza tra il primo e il terzo quartile è detta **scarto interquartile** o **intervallo interquartile**. Se tutti i valori cadono all'interno dell'intervallo (a,b) prendiamo il baffo inferiore come minimo e il baffo superiore come massimo. I numeri che non cadono nell'intervallo e risultano quindi essere fuori sono detti *valori anomali* o *outlier* e necessitano di uno studio per capirne le origini. 
Lo scopo del boxplot è quello di illustrare alcune caratteristiche di una distribuzione di frequenza come:

* la centralità
* la forma
* la dispersione
* la presenza di valori anomali

La centralità viene espressa dalla mediana. È possibile verificare la simmetria della distribuzione confrontando le differenze fra $Q_{3}$ - $Q_{2}$ e $Q_{2}$ - $Q_{1}$: se queste infatti risultano essere uguali o vicine allora la mediana si trova più o meno al centro della distribuzione, garantendo la simmetria dei dati.
I valori dei dati che sono al di sopra del baffo superior o al di sotto del baffo inferiore sono outliers e nel grafico vengano rappresentati sottoforma di punti.
Per la creazione di boxplot, R fornisce la funzione *boxplot()* . Il grafico può essere creato sia con orientamento verticale che orizzontale utilizzando il parametro *horizontal* che  di default è impostato a FALSE, indicante orientamento verticale. 

```{r}
boxplot(lavoro, col = "orange", main="Boxplot tasso cittadini non comunitari residenti per motivi di lavoro")
```

Come descritto precedentemente, gli estremi della scatola nel grafico sono rappresentati da $Q_{3}$ = 32.08 e da $Q_{1}$ = 23.57 mentre la linea orizzontale, la mediana, è in corrispondenza di $Q_{2}$ = 28.25 . Il baffo inferiore è pari a 10.90 ovvero al primo numero maggiore o uguale a $Q_{1}$ - 1.5 $*$ ($Q_{3}$ - $Q_{1}$), 23.7 - 1.5 $*$ (32.08 - 23.57) = 10.93. Il baffo superiore invece è 41.60 ovvero al primo valore del campione minore o uguale di $Q_{3}$ + 1.5 $*$ ($Q_{3}$ - $Q_{1}$), ossia 32.08 + 1.5 $*$ (32.08 - 23.57) = 44.845. Tutti i valori ricadono fra il minimo e il massimo quindi non abbiamo anomalie. Per quanto riguarda la simmetria abbiamo che $Q_{3}$ - $Q_{2}$, 32.08 - 28.25 = 3.5, e $Q_{2}$ - $Q_{1}$, 28.25 - 23.57 = 4.68. I valori sono diversi ma molto vicini. 

I boxplot per le restanti modalità sono:

```{r}
quantile(famiglia)
```

```{r}
summary(famiglia)
```


```{r}
boxplot(famiglia, col = "red", main="Boxplot tasso cittadini non comunitari residenti per motivi di famiglia")
```

In questo boxplot la mediana è spostata più verso l'alto, fattore che ci dice che la distribuzione non è simmetrica.

```{r}
quantile(studio)
```

```{r}
summary(studio)
```

```{r}
boxplot(studio, col = "green", main="Boxplot tasso cittadini non comunitari residenti per motivi di studio")
```


```{r}
quantile(asilo)
```

```{r}
summary(asilo)
```

```{r}
boxplot(asilo, col = "yellow",main="Boxplot tasso cittadini non comunitari residenti per motivi di asilo")
```
In questo boxplot è presente un valore anomale e, riferendoci alla tabella, scopriamo che è il Molise con 67.1. I baffo superiore è molto più grande di quello inferiore, dicendoci che la disperisione dei dati è maggiore. Anche la mediana non risulta essere al centro ma tende verso il basso incidendo sulla simmetria.

```{r}
quantile(altro)
```

```{r}
summary(altro)
```

```{r}
boxplot(altro, col = "purple", main="Boxplot tasso cittadini non comunitari residenti per altri motivi")
```

Anche in quest'ultimo boxplot è presente un valore anomale che esce al di fuori dell'intervallo. In questo caso, la regione è il Lazio con 9.79. La mediana risulta essere più in basso rispetto al centro.

Possiamo anche confrontare i diversi boxplot mettendoli tutti insieme in un unico grafico.

```{r}
boxplot(lavoro, famiglia, studio, asilo, altro, col = c("orange","red","green","yellow", "purple"), names = c("lavoro", "famiglia", "studio", "asilo", "altro"))
```

###Scatterplot

Gli **scatterplot** o **diagrammi di dispersione** consistono in rappresentazioni grafiche delle relazioni tra variabili quantitative. Quello che si fa è fissare la variabile da porre sull'asse delle ascisse e quella da porre sull'asse delle ordinate. Queste variabili vengono chiamate rispettivamente variabile **indipendente** e variabile **dipendente**. Iniziamo col creare quindi un data frame, un tipo di struttura dati a disposizione in R. All'interno di questo data frame inseriamo i vettori delle diverse modalità. 

```{r}
motivi <- data.frame(lavoro, famiglia, studio, asilo, altro)
```

Per realizzare uno scatterplot basta utilizzare la funzione *pairs()* darle in input il data frame appena creato. 

```{r}
pairs(motivi, main="Scatterplot per le coppie di variabili")
```

Le immagini mostrano le nuvole di punti ottenute considerando tutte le coppie di variabili. Almeno nella metà delle coppie, è presente una qualche relazione, anche accennata. 
Alcune invece, come il plot che mette in relazione lavoro e famiglia, non sembrano essere in relazione. 
È possibile anche stampare uno solo grafico alla volta utilizzando la funzione *plot()* dandole in input singoli vettori del data frame.

```{r}
plot(motivi$lavoro, motivi$famiglia, xlab="Lavoro", ylab="Famiglia", main="Motivi di lavoro in relazione ai motivi di famiglia")
```


## Statistica descrittiva univariata

Per i fenomeni quantitativi è utile definire la funzione di distribuzione empirica. Abbiamo due tipi di funzione di distribuzione empirica:

* funzione di distribuzione empirica discreta
* funzione di distribuzione empirica continua

### Funzione di distribuzione empirica discreta

Una funzione di distribuzione empirica discreta è una funzione utilizzata quando la nostra variabile assume valori discreti. Il fatto che i valori della variabile siano discreti, porta la funzione ad assumere una forma a gradini. Utilizzando le frequenze relative $f_{i}$ = $\frac{n_{i}}{n}$ con i = 1, 2, ..., k  e le frequenze relative cumulate $F_{i}$ =  $f_{1}$ + $f_{2}$ + ... +$f_{k}$ dove k è il numero discreto di valori che il nostro campione di dati può assumere.
La funzione di distribuzione empirica discreta è così definita:



dove:
* *#* è la cardinalità dell'insieme
* gli $z_{i}$ rappresentano i possibili valori assunti dal campione 
* gli $x_{i}$ i valori del campione
* gli $F_{i}$ la proporzione dei dati del campione minori o uguali di $z_{i}$

La funzione di distribuzione empirica discreta F(x) è definita per ogni x reale. 
R dispone della classe *stepfun* che implementa una serie di metodi per trattare funzioni a gradino. In particolare, la funzione *ecdf()*, acronimo di *empirical cumulative distribution function*, permette di disegnare il grafico della funzione di distribuzione empirica per le variabili quantitative discrete.

```{r}
plot(ecdf(famiglia), main = "Funzione di distribuzione empirica discreta")
```

I gradini sono tanti quanto i valori assunti dalla variabile e, siccome in questo vettore i numeri sono tutti differenti tranne che per una coppia, ha poco senso creare questo grafico. 
Prendendo il vettore studio però ed eliminando la parte decimale è possibile visualizzare un esempio di questo grafico.

```{r}
plot(ecdf(round(studio, digits = 0)), main="Funzione di distribuzione empirica discreta", col="red")
```

La funzione *round()* serve ad arrotondare un numero alla cifra specificata con il parametro *digits*.

### Funzione di distribuzione empirica continua

Per fenomeni quantitativi continui, la funzione di distribuzione empirica è una funzione **continua**, necessaria se i dati vengono raccolti in classi. Se i dati vengono quindi raccoli in k distinte classi $C_{1}$ = [$z_{1}$, $z_{2}$), $C_{2}$ = [$z_{3}$, $z_{4}$), ..., $C_{k}$ = [$z_{k}$, $z_{k+1}$]
La funzione di distribuzione empirica è così definita: 

Si noti che F(x) = 0 per x < $z_{1}$ , F(x) = 1 per x $\let$ $z_{k+1}$ mentre se $z_{i}$ < x < $z_{i+1}$ la funzione empirica coincide con il segmento che passa per i punti ($z_{i}$, $F_{i}$) e ($z_{i+1}$,$F_{i+1}$)

La suddivisione in classi adottata è la seguente: [0, 15), [15, 20), [20, 25)

```{r}
classi_empiriche <- c(0,15,25,30,35,40,45,50,55,60,70)

Ffamiglia <- cumsum(table(cut(famiglia, breaks=classi_empiriche, right =FALSE)))/length(famiglia)
Ffamiglia
```

Il vettore Fi contiene le frequenze relative cumulate dei tassi delle varie regioni associati alle varie classi.

```{r}
Ffamiglia <- c(0, Ffamiglia)
plot(classi_empiriche, Ffamiglia, type = "b", axes = FALSE, main = "Funzione di distribuzione empirica continua", ylab ="Funzione", xlab = "Classi", col = "red")
axis(1, classi_empiriche)
axis(2, format(Ffamiglia, digits=2))
box()
```

Utilizziamo c(0, Fi) per aggiungere uno zero all'inizio del vettore delle frequenze relative cumulate. Nella funzione *plot()* abbiamo utilizzato l'opzione *type = b* che ci consente di congiungere i punti successivi del grafico mediante delle linee continue ai cui estremi troviamo dei piccoli cerchi. L'opzione *axes = FALSE* consente di non tracciare gli assi. Mediante l'opzione *axis(1, classi)* si disegna l'asse orizzontale in basso e con *axis(2, format(Fi, digits=2))* si ottiene l'asse verticale di sinistra con una formattazione opportuna dei numeri. Con *box()* racchiudiamo tutto in un rettangolo. 

Utilizzando la stessa suddivisione in classi, creiamo il grafico per i vettori asilo e lavoro:

```{r}
Flavoro <- cumsum(table(cut(lavoro, breaks=classi_empiriche, right =FALSE)))/length(lavoro)
Flavoro <- c(0, Flavoro)
plot(classi_empiriche, Flavoro, type = "b", axes = FALSE, main = "Funzione di distribuzione empirica continua", ylab ="Funzione", xlab = "Classi", col = "red")
axis(1, classi_empiriche)
axis(2, format(Flavoro, digits=2))
box()
```

```{r}
Fasilo <- cumsum(table(cut(asilo, breaks=classi_empiriche, right =FALSE)))/length(asilo)
Fasilo <- c(0, Fasilo)
plot(classi_empiriche, Fasilo, type = "b", axes = FALSE, main = "Funzione di distribuzione empirica continua", ylab ="Funzione", xlab = "Classi", col = "red")
axis(1, classi_empiriche)
axis(2, format(Fasilo, digits=2))
box()
```

Siccome i vettori studio e altro risultano contenere valori decisamente piccoli, utilizziamo una suddivisione in classi diversa:

```{r}
classi_empiriche1 <- c(0,2,4,6,8,10)
Fstudio <- cumsum(table(cut(studio, breaks=classi_empiriche1, right =FALSE)))/length(studio)
Fstudio <- c(0, Fstudio)
plot(classi_empiriche1, Fstudio, type = "b", axes = FALSE, main = "Funzione di distribuzione empirica continua", ylab ="Funzione", xlab = "Classi", col = "red")
axis(1, classi_empiriche1)
axis(2, format(Fstudio, digits=2))
box()
```

```{r}
Faltro <- cumsum(table(cut(altro, breaks=classi_empiriche1, right =FALSE)))/length(altro)
Faltro <- c(0, Faltro)
plot(classi_empiriche1, Faltro, type = "b", axes = FALSE, main = "Funzione di distribuzione empirica continua", ylab ="Funzione", xlab = "Classi", col = "red")
axis(1, classi_empiriche1)
axis(2, format(Faltro, digits=2))
box()
```

### Indici di sintesi
Come visto prima, attraverso i boxplot è possibile rappresentare in maniera semplice la distribuzione di frequenza di un campione di dati numerico. Quello che faremo adesso è introdurre degli indici che servono a misurare quantitativamente alcune delle caratteristiche osservate nei boxplot e nei grafici di distribuzioni di frequenza.
Gli indici di **sintesi**, detti anche *statistiche*, sono utili nel descrivere dati numerici. In particolare questi indici sono: *media*, *moda*, *mediana*, *varianza*, *deviazione standard* e *coefficiente di variazione*. Le prime tre, media, mediana e moda, sono *misure di centralità* mentre le restanti tre misurano la *dispersione dei dati*. 

### Media, mediana e moda

#### Media

Supponiamo di avere a disposizione un insieme $x_{1}, x_{2}, ... ,x_{n}$ di n valori, chiamato *campione di ampiezza n*. La **media campionaria**, indicata con **$\bar{x}$** è la media aritmetica di questi valori.

**Inserire equazione**

Questa misura gode della proprietà di linearità. Inoltre, è possibile vedere la media come una media pesata dei valori distinti assunti dai dati. Ogni valore distinto usa come peso la sua frequenza relativa, ovvero la frazione dei dati uguale al suo valore. 

**Inserire equazione**

Per ogni valore $x_{i}$ si definisce lo *scarto della media campionaria* la quantità 

$s_{i} = x_{i}-\bar{x}$ con $(i = 1,2,...,n)$

che indica il grado di scostamento del singolo valore $x_{i}$ dalla media campionaria $\bar{x}$.
Si noti che la somma algebrica degli scarti della media campionaria è sempre *nulla*, risulta infatti che:

**Inserire equazione**

Va sottolineato che la media campionaria è sensibile ai valori anomali.

Per il calcolo della media campionaria, R fornisce la funzione *mean()*

```{r}
mean(lavoro)
```

```{r}
mean(famiglia)

```

```{r}
mean(studio)
```

```{r}
mean(asilo)
```

```{r}
mean(altro)
```

#### Mediana

Una seconda statistica che indica la centralità di un insieme di dati è la **mediana campionaria**. Assegnato un insieme di dati di ampiezza n, lo si ordini dal minore al maggiore. Se n è dispari, si definisce mediana campionaria il valore che è in posizione $\frac{(n+1)}{2}$, mentre se n risulta essere pari la mediana campionaria è definita come la media aritmetica dei valori che occupano le posizioni $\frac{n}{2}$ e $\frac{(n+1)}{2}$. Questa definizione di mediana campionaria bipartisce le osservazioni in due gruppi di uguale numerosità.
Il linguaggio R ci mette a disposizione la funzione *median()* per calcolare la mediana di un vettore contenente delle osservazioni. 
Di seguito, la funzione *median()* viene utilizzata per calcolare la mediana dei vettori a nostra disposizione:

```{r}
median(lavoro)
```

```{r}
median(famiglia)
```

```{r}
median(studio)
```

```{r}
median(asilo)
```

```{r}
median(altro)
```

Sia la media campionaria che la mediana campionaria risultano essere statistiche utili per descrivere la centralità dei dati. A dispetto però della media campionaria, la mediana dipende solo da uno o due dei valori centrali dei dati e non risente dei valori estremi (estremamente bassi o alti). Lo svantaggio di utilizzare la mediana è che bisogna prima ordinare i dati a dispozione prima di poterla calcolare.

### Moda

La terza statistica utilizzata per descrivere la centralità dei dati è la **moda campionaria**. La moda campionaria di un insieme di dati, se esiste, è la modalità a cui è associata la frequenza (assoluta o relativa) più elevata. Se esistono più modalità con frequenza massima, ciascuna di esse è detta **valore modale**. La moda quindi nient'altro è che il valore che si presenta con frequenza maggiore nell'insieme dei dati. Per definizione, è possibile utilizzare la moda anche per dati di tipo qualitativo, cosa che non è possibile fare con media e mediana. La moda può non esistere oppure non essere unica: quando non è unica, la distribuzione è detta *unimodale* mentre quando ci sono due o più mode diverse è detta *bimodale* o *multimodale*.
Non esiste in R una funzione per estrarre la moda da una distribuzione di dati poichè essa risulta facilmente estraibile osservando il grafico delle frequenze assolute. 
Si è optato lo stesso per definire una funzione in grado di ricavarla:

```{r}
moda <- function(v){
  y<-table(v)
  z<-which(y==max(y))
  return(c(z))
}
```

Applichiamo poi la moda a ciascun vettore della matrice:

```{r}
moda(lavoro)
```

```{r}
moda(famiglia)
```

```{r}
moda(studio)
```

```{r}
moda(asilo)
```

```{r}
moda(altro)
```

In quasi tutti i vettori considerati, la moda è risultata essere una buona statistica per misurare la centralità tranne nell'ultimo caso, col vettore *altro*, dove i dati sono molto diversi fra loro.

Dopo aver calcolato queste tre statistiche, è possibile descrivere la forma di una distribuzione confrontando la media campionaria e la mediana campionaria. Se queste due statistiche risultano essere uguali allora la distribuzione di frequenza tende ad essere simmetrica; se la media campionaria è maggiore della mediana campionaria allora la distribuzione sarà sbilanciata verso destra; se invece la media campionaria è sensibilimente minore della mediana campionaria allora la distribuzione di frequenza è più sbilanciata verso sinistra. 

## Mediana per distribuzione di frequenza

Un modo di procedere diverso per definire la mediana è quello di considerare le frequenze relative cumulate.
Sia X una variabile quantitativa e siano $z_{1} < z_{2} < ... < z_{k}$.
Considerato un campione ($x_{1}, x_{2}, ..., x_{n}$), siano $F_{i} = f_{1} + f_{2} + ... + f_{i}$ con $(i = 1, 2, ..., k)$ le frequenze relative cumulate.

La **mediana per una distribuzione di frequenze** è definita come la modalità i-esima $(i = 1, 2, ..., k)$ che soddisfa la doppia disuguaglianza:
$F_{i-1} < 0.5$, $F_{i} \geq 0.5$

Come si evince dalla definzione, la mediana di una distribuzione di frequenza è un valore di sintesi che indica un punto centrale intorno al quale si dispone la distribuzione di frequenza.

```{r}
par(mfrow = c(2,2))
plot(classi_empiriche, Flavoro, type="b", main="Funzione di distribuzione empirica discreta di lavoro", col="red")
abline(h=0.5, lty=2, col="blue")
plot(classi_empiriche, Ffamiglia, type="b", main="Funzione di distribuzione empirica discreta di famiglia", col="red")
abline(h=0.5, lty=2, col="blue")
plot(classi_empiriche, Fasilo, type="b", main="Funzione di distribuzione empirica discreta di asilo", col="red")
abline(h=0.5, lty=2, col="blue")
plot(classi_empiriche1, Fstudio, type="b", main="Funzione di distribuzione empirica discreta di studio", col="red")
abline(h=0.5, lty=2, col="blue")
plot(classi_empiriche1, Faltro, type="b", main="Funzione di distribuzione empirica discreta di altro", col="red")
abline(h=0.5, lty=2, col="blue")
```

Per ottenere il valore della mediana per la distribuzione di frequenze utilizziamo la funzione *quantile()*.

```{r}
quantile(lavoro, 0.5, type=1)
```
```{r}
quantile(famiglia, 0.5, type=1)
```

```{r}
quantile(studio, 0.5, type=1)
```

```{r}
quantile(asilo, 0.5, type=1)
```

```{r}
quantile(altro, 0.5, type=1)
```

### Quantili, percentili, decili e quartili

Oltre la mediana è possibile definire altri indici di posizione detti **quantili**, che dividono l'insieme dei dati ordinati in un numero di parti uguali. Supponiamo di avere a disposizione una variabile quantitativa con un certo numero di osservazioni disposte in ordine crescente. Possiamo dividere i dati in $\alpha$ gruppi, ognuno contenente circa lo stesso numero di elementi. Gli $\alpha-1$ numeri sono detti *quantili* di ordine $\alpha$. Solitamente possiamo dividere i dati in $\alpha = 4$ gruppi da 3 quantili detti *quartili*, oppure $\alpha = 10$ e 9 quantili detti *decili* o ancora $\alpha = 100$ e 99 quantili detti *percentili*. I quantili (percentili) sono indici di posizione non centrali utilizzati per insiemi numerosi di dati. 
Per il calcolo dei quantili R ha a disposizione la funzione *quantile(v, probs = , type = )*. Oltre al vettore, la funzione prende in input anche due ulteriori parametri:

* *probs* che rappresenta il vettore delle probabilità
* *type* a cui è possibile assegnare valori da 1 a 9 e indica l'algoritmo da utilzzare per il calcolo dei quantili. Infatti, R possiede per 9 algoritmi per il calcolo dei quantili e quello di default è il 7, basato su tecniche di interpolazione tra i punti. 

```{r}
quantile(lavoro)
```

```{r}
quantile(famiglia)
```

```{r}
quantile(studio)
```

```{r}
quantile(asilo)
```

```{r}
quantile(altro)
```

Abbiamo detto che R è in grado di utilizzare diversi algoritmi per il calcolo dei quantili. Mostriamo ora lavorando sul vettore famiglia, la differenza fra i vari algoritmi

```{r}
tipiquartili <- function(x){
  y<-numeric(0)
  for(i in 1:9){
    y<-rbind(y, c(quantile(x, 0, type=i), quantile(x, 0.25, type=i), quantile(x, 0.5, type=i), quantile(x, 0.75, type=i), quantile(x, 1, type=i)))
  }
  rownames(y) <- paste("type", 1:9)
  y
}
tipiquartili(famiglia)
```

Calcolando i quantili sul vettore famiglia con i differenti algoritmi è possibile notare che i risultati restituiti differiscono.

### Varianza, deviazione standard e coefficiente di variazione
Siccome gli indici di posizione non tengono conto della variabilità dei dati, abbiamo bisogno di introdurre due nuovi indici: *varianza campionaria* e *deviazione standard*. Questi due indici ci permettono di permettono di misurare la variabilità di una distribuzione di frequenza.
Diamo le definizioni di queste due misure:

Assegnato un insieme di dati numerici $x_{1}, x_{2}, ..., x_{n}$, si definisce **varianza campionaria**, indicata con $s^{2}$, la quantità:

$$s^2 = \frac{1}{n-1} \sum_{i=1}^n (x_{i} - \bar{x})$$ con n=2,3,...

dove $\bar{x}$ è la media campionaria. 

Definiamo come **devianzione standard**, indicata con s, la radice quadrata della varianza campionaria


